# Week1 GPSè¨˜éŒ²æ©Ÿèƒ½ - è©³ç´°åˆ†æ

## ğŸ“‹ ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹åˆ†æ

### ä¸»è¦ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹: GPSè»Œè·¡ã®è‡ªå‹•è¨˜éŒ²

**ã‚¢ã‚¯ã‚¿ãƒ¼**: ãŠå‡ºæ›ã‘ãƒ¦ãƒ¼ã‚¶ãƒ¼  
**ç›®æ¨™**: å¤–å‡ºä¸­ã®ç§»å‹•çµŒè·¯ã‚’è‡ªå‹•çš„ã«è¨˜éŒ²ã™ã‚‹  
**å‰ææ¡ä»¶**:

- ã‚¢ãƒ—ãƒªãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿
- ä½ç½®æƒ…å ±æ¨©é™ãŒæœªè¨­å®šã¾ãŸã¯è¨­å®šæ¸ˆã¿
- ãƒ‡ãƒã‚¤ã‚¹ã®GPSæ©Ÿèƒ½ãŒæœ‰åŠ¹

**æˆåŠŸã‚·ãƒŠãƒªã‚ª**:

1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¢ãƒ—ãƒªã‚’èµ·å‹•
2. ä½ç½®æƒ…å ±æ¨©é™ã®ç¢ºèªãƒ»å–å¾—
3. GPSè¨˜éŒ²ã‚µãƒ¼ãƒ“ã‚¹ã®é–‹å§‹
4. ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ã®ç¶™ç¶šè¨˜éŒ²
5. è¨˜éŒ²ã®åœæ­¢ã¨ä¿å­˜

**å¤±æ•—ã‚·ãƒŠãƒªã‚ª**:

- ä½ç½®æƒ…å ±æ¨©é™æ‹’å¦
- GPSæ©Ÿèƒ½ç„¡åŠ¹
- ãƒãƒƒãƒ†ãƒªãƒ¼ä¸è¶³
- ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å®¹é‡ä¸è¶³

---

## ğŸ¯ è©³ç´°ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã‚·ãƒŠãƒªã‚ª

### ã‚·ãƒŠãƒªã‚ª 1: åˆå›èµ·å‹•æ™‚ã®æ¨©é™å–å¾—

**çŠ¶æ³**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒåˆã‚ã¦ã‚¢ãƒ—ãƒªã‚’èµ·å‹•ã™ã‚‹

**æ­£å¸¸ãƒ•ãƒ­ãƒ¼**:

1. **èµ·å‹•**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒPathlyã‚¢ãƒ—ãƒªã‚’ã‚¿ãƒƒãƒ—ã—ã¦èµ·å‹•
2. **æ¨©é™ãƒã‚§ãƒƒã‚¯**: ã‚¢ãƒ—ãƒªãŒä½ç½®æƒ…å ±æ¨©é™ã®çŠ¶æ…‹ã‚’ç¢ºèª
3. **æ¨©é™è¦æ±‚**: ä½ç½®æƒ…å ±æ¨©é™ãŒæœªè¨±å¯ã®å ´åˆã€æ¨©é™è¦æ±‚ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
4. **æ¨©é™è¨±å¯**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€Œè¨±å¯ã€ã‚’ã‚¿ãƒƒãƒ—
5. **ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ¨©é™**: ã€Œå¸¸ã«è¨±å¯ã€ã®é¸æŠã‚’ä¿ƒã™
6. **è¨˜éŒ²æº–å‚™**: GPSè¨˜éŒ²ã‚µãƒ¼ãƒ“ã‚¹ãŒåˆ©ç”¨å¯èƒ½ã«ãªã‚‹
7. **UIæ›´æ–°**: è¨˜éŒ²é–‹å§‹ãƒœã‚¿ãƒ³ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ãªã‚‹

**ä»£æ›¿ãƒ•ãƒ­ãƒ¼**:

- **3a. æ¨©é™æ‹’å¦**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€Œæ‹’å¦ã€ã‚’ã‚¿ãƒƒãƒ—
  - 3a1. ã‚¢ãƒ—ãƒªæ©Ÿèƒ½èª¬æ˜ã‚’è¡¨ç¤º
  - 3a2. è¨­å®šç”»é¢ã¸ã®å°ç·šã‚’æä¾›
  - 3a3. æ¨©é™ãªã—ã§ã¯è¨˜éŒ²ä¸å¯ã®æ—¨ã‚’é€šçŸ¥

**æŠ€è¡“å®Ÿè£…ãƒã‚¤ãƒ³ãƒˆ**:

```kotlin
// æ¨©é™ãƒã‚§ãƒƒã‚¯ã¨è¦æ±‚ (Kotlin Coroutines)
class LocationPermissionManager {
    suspend fun checkAndRequestPermissions(activity: ComponentActivity): PermissionResult {
        return withContext(Dispatchers.Main) {
            when {
                hasLocationPermission() -> PermissionResult.GRANTED
                shouldShowRationale() -> {
                    showRationaleDialog()
                    requestPermission()
                }
                else -> requestPermission()
            }
        }
    }
}
```

---

### ã‚·ãƒŠãƒªã‚ª 2: GPSè¨˜éŒ²ã®é–‹å§‹

**çŠ¶æ³**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¤–å‡ºå‰ã«è¨˜éŒ²ã‚’é–‹å§‹ã™ã‚‹

**æ­£å¸¸ãƒ•ãƒ­ãƒ¼**:

1. **è¨˜éŒ²é–‹å§‹**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€Œè¨˜éŒ²é–‹å§‹ã€ãƒœã‚¿ãƒ³ã‚’ã‚¿ãƒƒãƒ—
2. **æ¨©é™ç¢ºèª**: ä½ç½®æƒ…å ±æ¨©é™ã®å†ç¢ºèª
3. **GPSæº–å‚™**: LocationManagerã®åˆæœŸåŒ–
4. **ã‚µãƒ¼ãƒ“ã‚¹é–‹å§‹**: ForegroundServiceã¨ã—ã¦GPSè¨˜éŒ²ã‚µãƒ¼ãƒ“ã‚¹é–‹å§‹
5. **é€šçŸ¥è¡¨ç¤º**: è¨˜éŒ²ä¸­ã‚’ç¤ºã™é€šçŸ¥ã‚’ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ã«è¡¨ç¤º
6. **åˆå›ä½ç½®å–å¾—**: æœ€åˆã®GPSåº§æ¨™ã‚’å–å¾—
7. **è¨˜éŒ²é–‹å§‹ç¢ºèª**: UIã«è¨˜éŒ²ä¸­ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¡¨ç¤º

**ä»£æ›¿ãƒ•ãƒ­ãƒ¼**:

- **2a. æ¨©é™å¤±åŠ¹**: æ¨©é™ãŒå–ã‚Šæ¶ˆã•ã‚Œã¦ã„ã‚‹å ´åˆ
  - 2a1. æ¨©é™å†å–å¾—ãƒ•ãƒ­ãƒ¼ã¸
- **6a. GPSå–å¾—å¤±æ•—**: åˆå›GPSå–å¾—ã«å¤±æ•—
  - 6a1. å†è©¦è¡Œãƒ­ã‚¸ãƒƒã‚¯å®Ÿè¡Œ
  - 6a2. æœ€å¤§3å›ãƒªãƒˆãƒ©ã‚¤å¾Œã‚¨ãƒ©ãƒ¼è¡¨ç¤º

**æŠ€è¡“å®Ÿè£…ãƒã‚¤ãƒ³ãƒˆ**:

```kotlin
// GPSè¨˜éŒ²ã‚µãƒ¼ãƒ“ã‚¹ (Foreground Service + Coroutines)
class LocationTrackingService : Service() {
    private val locationFlow = channelFlow {
        locationManager.requestLocationUpdates(
            LocationManager.GPS_PROVIDER,
            30_000L, // 30ç§’é–“éš”
            0f,
            locationListener
        )
    }.flowOn(Dispatchers.IO)

    private fun startTracking() {
        serviceScope.launch {
            locationFlow
                .catch { e -> handleLocationError(e) }
                .collect { location ->
                    saveLocationToDatabase(location)
                }
        }
    }
}
```

---

### ã‚·ãƒŠãƒªã‚ª 3: ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ã®ç¶™ç¶šè¨˜éŒ²

**çŠ¶æ³**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚¢ãƒ—ãƒªã‚’é–‰ã˜ã¦ã‚‚è¨˜éŒ²ãŒç¶™ç¶šã•ã‚Œã‚‹

**æ­£å¸¸ãƒ•ãƒ­ãƒ¼**:

1. **ã‚¢ãƒ—ãƒªæœ€å°åŒ–**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ›ãƒ¼ãƒ ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã‚¢ãƒ—ãƒªã‚’é–‰ã˜ã‚‹
2. **ã‚µãƒ¼ãƒ“ã‚¹ç¶™ç¶š**: ForegroundServiceãŒè¨˜éŒ²ã‚’ç¶™ç¶š
3. **å®šæœŸå–å¾—**: 30ç§’é–“éš”ã§GPSåº§æ¨™ã‚’å–å¾—
4. **ãƒ‡ãƒ¼ã‚¿ä¿å­˜**: å–å¾—ã—ãŸåº§æ¨™ã‚’ãƒ­ãƒ¼ã‚«ãƒ«DBã«ä¿å­˜
5. **é€šçŸ¥æ›´æ–°**: è¨˜éŒ²æ™‚é–“ãƒ»è·é›¢ã‚’é€šçŸ¥ã«åæ˜ 
6. **ãƒãƒƒãƒ†ãƒªãƒ¼æœ€é©åŒ–**: ä¸è¦ãªå‡¦ç†ã‚’åœæ­¢ã—ã¦ãƒãƒƒãƒ†ãƒªãƒ¼æ¶ˆè²»ã‚’æŠ‘åˆ¶

**ä»£æ›¿ãƒ•ãƒ­ãƒ¼**:

- **3a. GPSä¿¡å·ä½ä¸‹**: å±‹å†…ã‚„åœ°ä¸‹ã§GPSç²¾åº¦ãŒä½ä¸‹
  - 3a1. æœ€å¾Œã®æ—¢çŸ¥ä½ç½®ã‚’ä½¿ç”¨
  - 3a2. ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ä½ç½®æƒ…å ±ã§è£œå®Œ
- **6a. ãƒãƒƒãƒ†ãƒªãƒ¼ä½ä¸‹**: ãƒãƒƒãƒ†ãƒªãƒ¼ãŒ20%ä»¥ä¸‹ã«ãªã‚‹
  - 6a1. å–å¾—é–“éš”ã‚’60ç§’ã«å¤‰æ›´
  - 6a2. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«çœé›»åŠ›ãƒ¢ãƒ¼ãƒ‰ã‚’é€šçŸ¥

**æŠ€è¡“å®Ÿè£…ãƒã‚¤ãƒ³ãƒˆ**:

```kotlin
// ãƒãƒƒãƒ†ãƒªãƒ¼æœ€é©åŒ– + ã‚³ãƒ«ãƒ¼ãƒãƒ³
class LocationTrackingService {
    private fun adjustTrackingInterval() {
        serviceScope.launch {
            batteryLevelFlow
                .distinctUntilChanged()
                .collect { batteryLevel ->
                    val interval = when {
                        batteryLevel < 20 -> 60_000L // 1åˆ†é–“éš”
                        batteryLevel < 50 -> 45_000L // 45ç§’é–“éš”
                        else -> 30_000L // 30ç§’é–“éš”
                    }
                    updateLocationRequestInterval(interval)
                }
        }
    }
}
```

---

### ã‚·ãƒŠãƒªã‚ª 4: è¨˜éŒ²ã®åœæ­¢ã¨ä¿å­˜

**çŠ¶æ³**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå¸°å®…å¾Œã«è¨˜éŒ²ã‚’åœæ­¢ã™ã‚‹

**æ­£å¸¸ãƒ•ãƒ­ãƒ¼**:

1. **åœæ­¢æ“ä½œ**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€Œè¨˜éŒ²åœæ­¢ã€ãƒœã‚¿ãƒ³ã‚’ã‚¿ãƒƒãƒ—
2. **æœ€çµ‚ä½ç½®å–å¾—**: æœ€å¾Œã®GPSåº§æ¨™ã‚’å–å¾—
3. **ã‚µãƒ¼ãƒ“ã‚¹åœæ­¢**: LocationTrackingServiceã‚’åœæ­¢
4. **é€šçŸ¥å‰Šé™¤**: ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ã‹ã‚‰è¨˜éŒ²ä¸­é€šçŸ¥ã‚’å‰Šé™¤
5. **ãƒ‡ãƒ¼ã‚¿æ•´ç†**: è¨˜éŒ²ãƒ‡ãƒ¼ã‚¿ã®æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
6. **çµ±è¨ˆè¨ˆç®—**: ç·ç§»å‹•è·é›¢ãƒ»æ™‚é–“ã‚’è¨ˆç®—
7. **ä¿å­˜å®Œäº†**: è¨˜éŒ²å®Œäº†ã‚’é€šçŸ¥

**æŠ€è¡“å®Ÿè£…ãƒã‚¤ãƒ³ãƒˆ**:

```kotlin
// è¨˜éŒ²åœæ­¢ã¨ãƒ‡ãƒ¼ã‚¿å‡¦ç†
class TrackingRepository {
    suspend fun stopTracking(trackId: String): TrackingSummary {
        return withContext(Dispatchers.IO) {
            val track = trackDao.getTrackById(trackId)
            val gpsPoints = gpsPointDao.getPointsByTrackId(trackId)

            val summary = calculateTrackingSummary(gpsPoints)
            trackDao.updateTrackEndTime(trackId, System.currentTimeMillis())

            summary
        }
    }

    private fun calculateTrackingSummary(points: List<GpsPoint>): TrackingSummary {
        val totalDistance = points.zipWithNext { a, b ->
            calculateDistance(a.latitude, a.longitude, b.latitude, b.longitude)
        }.sum()

        return TrackingSummary(
            totalDistance = totalDistance,
            duration = points.last().timestamp - points.first().timestamp,
            pointCount = points.size
        )
    }
}
```

---

## âš™ï¸ Android Kotlin + ã‚³ãƒ«ãƒ¼ãƒãƒ³å®Ÿè£…ã®æŠ€è¡“ãƒã‚¤ãƒ³ãƒˆ

### 1. ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

```kotlin
// MVVM + Clean Architecture
class LocationTrackingViewModel(
    private val trackingRepository: TrackingRepository,
    private val locationService: LocationTrackingService
) : ViewModel() {

    private val _trackingState = MutableStateFlow(TrackingState.STOPPED)
    val trackingState: StateFlow<TrackingState> = _trackingState.asStateFlow()

    fun startTracking() {
        viewModelScope.launch {
            try {
                _trackingState.value = TrackingState.STARTING
                val trackId = trackingRepository.createNewTrack()
                locationService.startTracking(trackId)
                _trackingState.value = TrackingState.RECORDING
            } catch (e: Exception) {
                _trackingState.value = TrackingState.ERROR(e.message)
            }
        }
    }
}
```

### 2. ã‚³ãƒ«ãƒ¼ãƒãƒ³ãƒ™ãƒ¼ã‚¹ã®GPSå–å¾—

```kotlin
class LocationProvider {
    fun getLocationUpdates(): Flow<Location> = callbackFlow {
        val locationListener = LocationListener { location ->
            trySend(location)
        }

        locationManager.requestLocationUpdates(
            LocationManager.GPS_PROVIDER,
            30_000L,
            0f,
            locationListener
        )

        awaitClose {
            locationManager.removeUpdates(locationListener)
        }
    }.flowOn(Dispatchers.IO)
}
```

### 3. Room ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ

```kotlin
@Entity(tableName = "tracks")
data class Track(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    val startTime: Long,
    val endTime: Long? = null,
    val isActive: Boolean = true
)

@Entity(tableName = "gps_points")
data class GpsPoint(
    @PrimaryKey val id: String = UUID.randomUUID().toString(),
    val trackId: String,
    val latitude: Double,
    val longitude: Double,
    val accuracy: Float,
    val timestamp: Long,
    val speed: Float? = null
)

@Dao
interface GpsPointDao {
    @Insert
    suspend fun insertGpsPoint(point: GpsPoint)

    @Query("SELECT * FROM gps_points WHERE trackId = :trackId ORDER BY timestamp ASC")
    suspend fun getPointsByTrackId(trackId: String): List<GpsPoint>
}
```

### 4. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

```kotlin
class LocationTrackingService {
    private fun handleLocationError(error: Throwable) {
        when (error) {
            is SecurityException -> notifyPermissionError()
            is LocationException -> retryLocationRequest()
            else -> {
                Timber.e(error, "Unexpected location error")
                stopSelf()
            }
        }
    }

    private suspend fun retryLocationRequest() {
        repeat(3) { attempt ->
            delay(5000 * (attempt + 1)) // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
            try {
                requestLocationUpdates()
                return
            } catch (e: Exception) {
                if (attempt == 2) throw e
            }
        }
    }
}
```

---

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒæ…®äº‹é …

### ãƒãƒƒãƒ†ãƒªãƒ¼æœ€é©åŒ–

- GPSå–å¾—é–“éš”ã®å‹•çš„èª¿æ•´
- ä¸è¦ãªå‡¦ç†ã®åœæ­¢
- ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰åˆ¶é™ã¸ã®å¯¾å¿œ

### ãƒ¡ãƒ¢ãƒªç®¡ç†

- GPSãƒã‚¤ãƒ³ãƒˆã®ãƒãƒƒãƒå‡¦ç†
- å¤ã„ãƒ‡ãƒ¼ã‚¿ã®å®šæœŸå‰Šé™¤
- Flow ã«ã‚ˆã‚‹åå¿œæ€§ã¨ãƒ¡ãƒ¢ãƒªåŠ¹ç‡

### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æœ€é©åŒ–

- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨­å®š
- ãƒãƒƒãƒInsert
- ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ç®¡ç†

---

## ğŸ§ª ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### å˜ä½“ãƒ†ã‚¹ãƒˆ

```kotlin
class LocationTrackingRepositoryTest {
    @Test
    fun `GPSè¨˜éŒ²é–‹å§‹æ™‚ã«æ–°ã—ã„TrackãŒä½œæˆã•ã‚Œã‚‹`() = runTest {
        // Given
        val repository = LocationTrackingRepository(mockDao)

        // When
        val trackId = repository.startNewTracking()

        // Then
        verify(mockDao).insertTrack(any())
        assertThat(trackId).isNotEmpty()
    }
}
```

### çµ±åˆãƒ†ã‚¹ãƒˆ

```kotlin
@Test
fun `GPSè¨˜éŒ²ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä¿å­˜ã¾ã§ä¸€é€£ã®æµã‚Œ`() = runTest {
    // GPSå–å¾— â†’ ãƒ‡ãƒ¼ã‚¿å¤‰æ› â†’ DBä¿å­˜ã®æµã‚Œã‚’ãƒ†ã‚¹ãƒˆ
}
```

### UI ãƒ†ã‚¹ãƒˆ

```kotlin
@Test
fun `è¨˜éŒ²é–‹å§‹ãƒœã‚¿ãƒ³ã‚¿ãƒƒãƒ—ã§è¨˜éŒ²ãŒé–‹å§‹ã•ã‚Œã‚‹`() {
    // Jetpack Compose UIãƒ†ã‚¹ãƒˆ
}
```

ã“ã®è©³ç´°åˆ†æã«ã‚ˆã‚Šã€Week1ã®GPSè¨˜éŒ²æ©Ÿèƒ½ã®å®Ÿè£…ã«å¿…è¦ãªå…¨ã¦ã®è¦ç´ ãŒæ˜ç¢ºã«ãªã‚Šã¾ã—ãŸã€‚
